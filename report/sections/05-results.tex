\section{Results}

In this section, we report on the evaluation of the practicality of
our discipline.

{\bf RQ1.} How hard is it to adhere to the discipline of writing API tests?

{\bf RQ2.} Given our idealized API tests, does our tool detect SemVer violations?

We used the test suite of mocha as our starting point. The developers
identify the ‘jsapi’ test suite as their interface tests. This
consists of 66 tests. According to our discipline (assuming the mocha
developers had adopted our discipline), the tests included with mocha
version 1.0.0 would pass when run against every version in the 1.X.Y
range. There are 50 versions in this range. We found that 10\% of the
jsapi tests from version 1.0.0 (7 out of the 66) failed on subsequent
versions.

Since mocha developers are not using our discipline, we expect some of
these failures to be due to not following the discipline; the test
depends (either explicitly or implicitly) upon API secrets. These
cases do not necessarily indicate SemVer violations, as long as the
removing the dependence on API secrets makes the tests pass. We
manually inspected each failing jsapi test for API secrets, and
refactored the test to remove the secret.

We found that 4 of the 7 failures were due to dependence on API
secrets. The failure in each case was similar, and it was possible to
remove the API secrets so that the test conformed with our discipline.

We found that in one case, the failure was due to inconsistent
dependencies between different versions of our subject
program. Fortunately, in this case the dependency was used only by the
test suite, so we could change it without affecting the
library. Lesson learned: in order for our cross-version testing to
work, a library should only migrate to new major versions of its
dependencies at major version releases. This would also eliminate a
major cause of “dependency hell”.  We found that in one case, the test
failed was a real SemVer violation.

The manual inspection of the failing jsapi tests to identify and
remove API secrets required 4 hours of effort by a developer
unfamiliar with mocha.

We summarize the 6 failing jsapi tests, our diagnosis of the cause of
the failure (SemVer violation or exposed secret), and in the cases of
exposed secrets, the fix required for the test to conform to our
discipline.

\subsection{Failure 1: Console output format changes.}
@api private.

\subsection{Failure 2: Incompatible dependency versions.}
@api public

\subsection{Failure 3: Error message changes.}
@api private

{\bf Test description: }
\begin{verbatim}
Runnable(title, fn) .run(fn) when async when the callback is invoked several times with an error should emit a single "error" event:
\end{verbatim}

In addition to testing that only a single error event is emitted,
version 1.0.0 also tests which error event it is. The error event
changes at version 1.3.0, from being an error created by mocha
indicating improper usage of its API, to one of the errors passed by
the client to the callback. This is a borderline case: we might
consider that the exceptions thrown by mocha to its clients are part
of the API, so this change might be considered a violation. However,
the test description mentions only the number of error events that
should be omitted, so we considered the actual error event to be
secret, and removed it from the test.

\subsection{Failure 4: SemVer violation.}
@api private

{\bf Test description:}
\begin{verbatim}
Runner .failHook(hoot, err) should emit "end":
\end{verbatim}

In version 1.21.5, this test is changed to:
\begin{verbatim}
Runner .failHook(hoot, err) should emit "end" if suite bail is true
\end{verbatim}

The property suite.bail was added to the runner object, allowing
clients to optionally allow the test to continue after the failHook is
called. In previous versions, the failHook always exits
immediately. The test fails because the default value of suite.bail is
“false”, so if a client upgrades mocha to version 1.21.5, the “end”
event will no longer be emitted. This is a breaking change in a patch
version, and thus would be a SemVer violation, except the docstring
for the method annotates the method as “@api private”, so this test
should not actually be part of the API specification.

\subsection{Confounding Factors}
\begin{itemize}
\item These tests were identified by the mocha developers as the
  ``Javascript API tests''. We assume that this consistently means the
  API between mocha and its client. However, this may not always be
  the case. In practice, this test suite tests internal interfaces as
  well as the external client-facing interface.
\item 
\end{itemize}