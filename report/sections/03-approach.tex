\section{Approach}

Our approach consists of defining an interface specification, which is a
special kind of tests, and a new discipline for writing these tests, and a tool
that is able to detect SemVer violations in a library.

\subsection{Interface Specifications}

\begin{definition}\textit{Interface Specification.}
An interface specification is a collection of tests that given an
implementation and returns a list of interface violations. 
$$\text{Spec} : \text{Impl} \to \powerset{\text{Violation}}$$
A violation is a identifier of a failed test. A specification
\begin{enumerate}
    \item Does not test anything secret, e.i.\ something that is subject to change.
    \item Does test everything that a client can rely on.  
\end{enumerate}
\end{definition}

The interface is a two sided contract. One one side, the library
clearly specifies what can be relied upon. On the other side, clients
should not rely upon anything that is not specified in the interface
tests.  Doing so would tightly couple the client to a particular
library version, making upgrading the library unsafe. Our interface
specification is both sound and complete by definition.  Following the
definition we have created a discipline of interface specification
using tests. We use the RFC 2119\footnote{The key words ``MUST'',
  ``MUST NOT'', ``REQUIRED'', ``SHALL'', ``SHALL NOT'', ``SHOULD'',
  ``SHOULD NOT'', ``RECOMMENDED'', ``MAY'', and ``OPTIONAL'' in this
  document are to be interpreted as described in RFC
  2119\cite{rfc2119}.} standard to describe the discipline.

\begin{enumerate}
    \item The library MUST clearly separate implementation specifications from
    other tests.
    \item Any released library version MUST be tested against the corresponding
    specification, and have no interface violations.
    \item Any feature exposed by the library, but not tested, SHOULD be
    considered a secret, and not be used by a client.
    \item A client MAY rely on any feature tested by the specification.
\end{enumerate}

This definition and discipline is flexible enough that it can describe
an interface, while still being machine-checkable. \marktodo{Any
  specification is a trade-off between machine power and API
  expressed}{Matt does not understand this sentence}.

\marktodo{Move this paragraph to section on limitations and future
  work?}{} This definition of course has some limitations. For
example, a test \texttt{assert add (2, 3) == 5} only checks that the
sum of 2 and 3 is 5. The client may incorrectly interpret this as
saying that the sum of any two numbers is 5, or even that the sum of
any two objects is 5. We conjecture that such problems could be
addressed by adding more tests, or by using techniques such as
concolic testing~\cite{sen05-cute} or random
testing~\cite{quickcheck}. The advantage of our approach is that the
interface and its guarantees are concretely described and
machine-checkable.

\subsection{Semantic Versioning using Interface Specifications}

To show that the technique is useful in practice, we have chosen to implement
semantic versioning based of our interface specifications.

\begin{definition}\textit{Semantic Versioning} (SemVer) is a way of describing
intention, and giving guarantees using version numbers\cite{semver}.
Related to to the last version $X.Y.Z$, the next version has to
monotonically increasing, meaning that it has to satisfy one of the
following rules.
$$ \text{Version} : \mathbb{N} \times \mathbb{N} \times \mathbb{N} $$

\begin{enumerate}
    \item A patch release has number $X.Y.Z'$, where $Z < Z'$. It may include
    bug fixes only, no new features or breaking changes.
    
    \item A minor release has number $X.Y'.Z'$, where $Y < Y'$. It may include
    bug fixes or new features, but no breaking changes.
    
    \item A major release has number $X'.Y'.Z'$, where $X < X'$. It may include
    bug fixes, new features, and breaking changes.
    
    \item Any releases in the range $0.Y'.Z'$, where $X = 0$ and $Y < Y'$ or $Z
    < Z'$ is unstable and the interface can change without warning.
\end{enumerate}

\end{definition}

We have chosen semantic versioning because it is a widely used
convention for managing dependencies that evolve independently of
their clients.
%
It is also encouraged and supported by package managers like
\emph{npm}, and \emph{bower}.
%
\marktodo{Both package managers depend heavily on that dependencies
  follow the SemVer policy}{check this. Matt's unsure about this.}.
%
There are several shortcomings with the current state of the
practice. 
%
First, developers choose version numbers for a new release primarily
based on intuition, which can be error-prone. What they consider to be
a bugfix might actually change the behavior that their clients rely
on.
%
A second problem can be seen as a consequence of the first. Clients
are often suspicious of upgrades to some or all of their dependencies,
and put strict constraints on them to prevent their package manager
from installing untested dependencies. 
%
In systems containing many independently-maintained modules, this can
lead to ``dependency hell''\cite{hell}, in which two modules depend on
incompatible versions of a third module. \marktodo{A figure depicting
  dep hell would be nice here. Something like ``Program contains
  modules A and B. A depends on C version 1.X, B depends on C version
  2.X''}{}
%
The root cause of these problems is an informal and often implicit
descriptions of what ``the interface'' is, i.e. what the clients can
depend over time.
%
Our approach solves this problem by using tests to describe an
interface. Tests are expressive enough to specify behavioral contracts
that are difficult or impossible to express in traditional
specifications languages or type systems. They also allow us to build
tools that can automatically verify SemVer compliance, or recommend
version numbers for new releases.

Semantic version numbers summarize the possible differences between
releases of a library, in particular, the possible differences visible
to a client. For example, a patch release can fix some buggy
behaviors, but must not add new behavior or break any old behavior. A
minor release can fix bugs and add new behavior, but must not break
old behavior.

To verify compliance to semantic versioning, we examine a series of
releases.
%
We define a release as a tuple of a version number, an implementation
and a specification.
$$ \text{Release} : \text{Ver} \times \text{Impl} \times \text{Spec} $$
%
We apply a novel \emph{Cross-Version Testing} approach to ensure that
each release satisfies the specifications of a range of release,
according to the rules of Semantic Versioning. In particular, we test
each release against the interface test suites of certain {\em other}
releases. According to our specification scheme, any failing tests
represent violations of Semantic Versioning.

Given a release of interest and the complete set of releases, our
cross-version testing tool will produce a set of implementations and
specifications. A particular implementation and specification are
included in the output set if SemVer requires that the implementation
meet the specification, but this is not the case.
$$
CVT : \text{Release} \times \powerset{\text{Release}} \to \powerset{\text{Spec} \times \text{Impl}}
$$

{\bf Why do we do this? Why is it a reasonable thing to do?}
Cross-version testing allows developers to refactor their interface
tests as needed, without introducing difficult problems surrounding
equivalence of specifications. \marktodo{Probably need to say more
  about this somewhere}{}.

{\bf The rules:} \marktodo{Below needs to be updated. It's assuming
  that the release is ``newer'' than the set of releases. In general,
  it will be (any) one of them}{}.

\begin{enumerate}
\item The implementation of a release must meet the specification of
  that release;
  $$ Refl(r) = \{(s, i)\} \text{ where } ((x,y,z), i, s) = r $$
    
\item \marktodo{There is as yet no mention of a ``new'' release, or of
    ``previous'' releases.}{} the new release version must be greater
  than all previous versions, as described in the semantic versioning
  (Reflective Test);
    \begin{align*}
        \forall r' \in rs. & ((x,y,z), \_,\_) = r \\ 
                           & \land ((x',y',z'), \_, \_) = r' \\ 
                           & \land \bigvee
        \begin{cases}
            x' < x \\
            x' = x \land y' < y \\
            x' = x \land y = y' \land z' < z
        \end{cases}
    \end{align*}
    
    \marktodo{Also, $r$ is a free variable. where is it supposed to be quantified?}{}

    \item all previous implementations with versions in same minor version as the
    new release, must meet new specification without violations (Added Feature
    Test);
    $$AFT(r, rs) = \left\{ (s, i')\ \vline\ 
        \begin{matrix}
            r' \in rs \\
        ((x,y,z), \_, s) = r \\ 
        ((x,y,z'), i', \_) = r'\\
        z' < z \\
        \end{matrix}
    \right\}$$

    \item and the new implementation must meet all previous specifications in the same major version as the new
        release, without violations (Breaking Change Test).
    $$BCT(r, rs) = \left\{ (s', i)\ \vline\ 
        \begin{matrix}
            r' \in rs \\
        ((x, y, z), i, \_) = r \\ 
        ((x, y', z'), \_, s') = r'\\
        y' < y \\
        \end{matrix}
    \right\}$$
\end{enumerate}

If all the steps are passed, the release is following SemVer. Assuming that the 
second point is uphold, we can write down the expression for cross version testing. 
$$ CVT(r, rs) = Refl(r) \cup BCT(r, rs) \cup AFT(r, rs) $$

\begin{theorem}[Soundness]
Given a release and a release history, our algorithm will reject the release if
and if it violates SemVer in relation to the release history.
\end{theorem}

\begin{proof}[sketch]
If a release is rejected, it must have failed in one of the 4 conditions. 
\begin{itemize}
  \item If the first condition failed, the release is invalid, and semantic
      version does not apply to broken releases. 
  \item If the second condition failed, then the patch did not follow the
      monotonic requirement of SemVer. 
  \item If the third requirement failed, some previous release, in the same
      minor version, have an implementation which violates something the specs
      of the current version. This means that the specs must be testing a new
      feature or have a breaking change, and this violates the first rule of
      SemVer.
  \item If the third requirement failed, some previous release, in the same
      major version,  must have a spec which is violated by the current
      implementation. This means that something which was guaranteed has been
      broken; which makes this a breaking change. Since the new release is at
      most a minor release compared, this violates the second rule of SemVer.
\end{itemize}
Because all possible failed cases is the result of a SemVer violation, the
algorithm is guaranteed to only reject a release if SemVer is violated.
\end{proof}

\begin{theorem}[Completness]
Given a release and a release history, our algorithm will accept the release if
and if adheed to SemVer in relation to the release history.
\end{theorem}

\begin{proof}[sketch]
If a release is wrongly accepted it must have not satisfied any of the SemVer
rules. 

\begin{itemize}
    \item If the new release is a major release, there is no way to violate the
    SemVer rules. If the new release is a minor release, it must contain a breaking
    change to violate SemVer. 
    \item If the new release is a minor release it would have been checked against all
    previous specifications in the major version, and passed without violations.
    This means that in respect to any previous version there is no breaking
    changes. So the new release does not violate SemVer.\
    \item If the new release is a patch release it would both have been checked against all 
    previous specifications and run the current new specification on each
    implementation with the same minor version. Nothing new has been added to the
    specification, so no (documented) features has been added. This release has not
    violated SemVer.
\end{itemize}

Because any version release accepted, whether it is patch, minor, major will all be according to 
SemVer, our tool can not accept a wrong release.
\end{proof}

\subsection{Pragmatics}
What is required of library authors that want to adopt our approach?
Here we discuss some high-level requirements that should be followed.

\begin{itemize}
\item A library should upper-bound their dependencies to stay within
  the current major version, since updrading to the next major version
  of a dependency may introduce a breaking change, which in turn could
  cause a breaking change for the library itself. We found this
  problem with mocha, and had to modify its {\tt package.json} file to
  correct it.
\item NPM packages specify a set of {\tt devDependencies} in the {\tt
    package.json}, which are the dependencies needed by the test suite
  but not the library itself. When cross-version testing, it is
  important to use the {\tt devDependencies} of the tests, not those
  of the library. Therefore, we found that we had to modify {\tt
    package.json} of the library each time we ran a cross-version
  test.
\end{itemize}
